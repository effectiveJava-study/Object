# 쳅터05. 책임 할당하기

책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다는 것이다.

이번 장에서 살펴볼 GRASP 패턴은 책임 할당의 어려움을 해결하기 위한 답을 제시해 줄 것이다. GRASP 패턴을 이해하고 나면 응집도와 결합도, 캡슐화 같은 다양한 기준에 따라 책임을 할당하고 결과를 트레이드오프할 수 있는 기준을 배우게 될 것이다.

## 01. 책임 주도 설계를 향해

데이터 중심의 설계에서 책임 중심 설계로 전환하기 위해 따라야 하는 두 가지 원칙

- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

### 데이터보다 행동을 먼저 결정하라

책임 중심의 설계에서는 객체의 행동, 즉 책임을 먼저 결정한 후에 객체의 상태를 결정하는 것이다.

### 협력이라는 문맥 안에서 책임을 결정하라

협력에 적합한 책임을 수확하기 위해서는 객체를 결정한 후에 메시지를 선택하는 것이 아니라 메시지를 결정한 후에 객체를 선택해야 한다. **메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것**이다.

메시지를 먼저 결정하기 때문에 메시지 송신자는 메시지 수신자에 대한 어떠한 가정도 할 수 없다. 메시지 전송자의 관점에서 메시지 수신자가 깔끔하게 **캡슐화** 되는 것이다.

### 책임 주도 설계

3장에서 설명한 책임 주도 설계의 흐름을 다시 나열한 것이다.

- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

이번 장에서는 책임 관점에서 영화 예매 시스템이 완성되는 과정을 살펴봄으로써 객체에 책임을 할당하는 기본적인 원칙일 이해하게 될 수 있다.

## 02. 책임 할당을 위한 GRASP 패턴

**GRASP 패턴**은 “General Responsibility Assignment Software Pattern (일반적인 책임 할당을 위한 소프트웨어 패턴)” 의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.

### 도메인 개념에서 출발하기

![5-1](https://github.com/effectiveJava-study/Object/assets/10612909/4714e8fc-9093-4958-8bd9-8d6c35688a3b)

위 그림은 영화 예매 시스템을 구성하는 도메인 개념과 개념 사이의 관계를 대략적으로 표현한 것이다.

설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다. 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행하라.

### 정보 전문가에게 책임을 할당하라

책임 주도 설계 방식의 첫 단계는 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다. 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작한다.

메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야 한다.

따라서 밑에 두 가지 질문에 답하면 된다.

- 메시지를 전송할 객체는 무엇을 원하는가?
- 메시지를 수신할 적합한 객체는 누구인가?

객체의 책임과 책임을 수행하는 데 필요한 상태는 동일한 객체 안에 존재해야 한다. 따라서 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다. GRASP에서는 이를 **INFORMATION EXPERT(정보 전문가)** 패턴이라고 부른다.

여기서 얘기하는 정보는 데이터와 다르다. 책임을 수행하는 객체가 정보를 ‘알고’ 있다고 해서 그 정보를 ‘저장’ 하고 있을 필요는 없다.

![5-2](https://github.com/effectiveJava-study/Object/assets/10612909/b5675aec-c34b-4e1d-beed-35dfa6658c93)

### 높은 응집도와 낮은 결합도

설계는 트레이드오프 활동이라는 것을 기억하라.

올바른 책임 할당을 위해 INFORMATION EXPERT 패턴 이외의 다른 책임 할당 패턴들을 함께 고려할 필요가 있다.

![5-3](https://github.com/effectiveJava-study/Object/assets/10612909/6f00a086-4d1b-40f8-9ba2-f4f5e551973b)

위 설계대로 Screening과 DiscountCondition이 협력하면 안되는 걸까? 왜 Movie가 DiscountCondition과 협력하는 방법을 선택한 걸까?

그 이유는 응집도와 결합도에 있다.

**LOW COUPLING 패턴**

- 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.
- 상영이 2개와 협력하는 구조는 결합도가 높아져 좋지 않은 설계이다.

**HIGH COHESION 패턴**

- 높은 응집도를 유지할 수 있게 책임을 할당하라.
- 위 사진의 구조는 Screening에게 영화 요금 계산 책임이 분산된다. 즉 Screening의 책임이 늘어난다.
- 이는 같이 변경될 여지도 증가한다는 뜻이다.

**LOW COUPLING 패턴**과 **HIGH COHESION 패턴**은 설계를 진행하면서 책임과 협력의 품질을 검토하는 데 사용할 수 있는 중요한 평가 기준이다.

### 창조자에게 객체 생성 책임을 할당하라

GRASP의 **CREATOR(창조자) 패턴**은 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.

아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라.

- B가 A 객체를 포함하거나 참조한다.
- B가 A 객체를 기록한다.
- B가 A 객체를 긴밀하게 사용한다
- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다(이 경우 B는 A에 대한 정보 전문가다.)

이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.

![5-4](https://github.com/effectiveJava-study/Object/assets/10612909/fb9126eb-59fc-4653-947b-9584103ada5d)

위 그림에서는 Reservation을 잘 알고 있거나, 긴밀하게 사용하거나, 초기화에 필요한 데이터를 가지고 있는 객체는 Screening 이기 때문에 Screening을 Reservation의 CREATOR로 선택하는 것이 적절해 보인다.

## 03. 구현을 통한 검증

### DiscountCondition 개선하기

DiscountCondition의 가장 큰 문제점은 변경에 취약한 클래스를 포함하고 있다는 것이다.

- 새로운 할인 조건 추가
    - 새로운 할인 조건 추가시 isSatisfiedBy의 조건 구문을 수정해야 하고 새로운 데이터를 필요로하는 경우 속성도 추가해야 한다.
- 순번 조건을 판단하는 로직 변경
    - Sequence 조건 판단 로직 변경시 구현 변경, 조건 판단에 필요한 데이터가 바뀔 경우 속성도 바뀌어야 한다.
- 기간 조건을 판단하는 로직이 변경되는 경우
    - Period 조건 판단 로직 변경시 구현 변경, 조건 판단에 필요한 데이터가 바뀔 경우 속성도 바뀌어야 한다.

DiscountCondition은 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다. 따라서 응집도가 초래하는 문제를 해결하기 위해서는 **변경의 이유에 따라 클래스를 분리해야 한다.**

코드를 통해 변경의 이유를 파악할 수 있는 **첫 번째 방법은 인스턴스 변수가 초기화 되는 시점을 살펴보는 것이다.**

응집도가 높은 클래스는 인스턴스를 생성할때 모든 속성을 함께 초기화 한다.

클래스 속성이 서로 다른 시점에 초기화 되거나 일부만 초기화 된다는 것은 응집도가 낮다는 증거다.

함께 초기화 되는 속성을 기준으로 코드를 분리해야한다.

**두 번째 방법은 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보는 것이다.**

모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다.

**클래스 응집도 판단하기**

클래스가 다음과 같은 징후로 몸살을 앓고 있다면 클래스의 응집도는 낮은 것이다.

- 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라.
- 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화 되는 속성의 그릅을 기준으로 클래스를 분리하라.
- 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라.

### 타입 분리하기

DiscountCondition의 가장 큰 문제는 순번 조건과 기간 조건이라는 두 개의 독립적인 타입이 하나의 클래스 안에 공존하고 있다는 점이다. 해결 방법으로 두 타입을 두개의 클래스로(SequenceCondition, PeriodCondition) 로 분리하는 것이다.

![5-5](https://github.com/effectiveJava-study/Object/assets/10612909/cbf86be5-bc16-45cb-baa9-21855de0c268)

하지만 이 방법은 두 가지 새로운 문제를 야기한다.

1. 결합된 클래스가 1개에서 2개로 증가하여 결합도가 높아졌다.
2. 새로운 할인 조건을 추가하기가 더 어려워졌다. List도 추가해야 하고, 만족 여부 메서드도 추가해야한다.

DiscountCondition의 입장에서 보면 응집도는 높아졌지만 변경과 캡슐화라는 관점에서 보면 설계의 품질이 나빠졌다.

### 다형성을 통해 분리하기

**역할**은 협력 안에서 대체 가능성을 의미하기 때문에 SequenceCondition과 PeriodCondition에 역할의 개념을 적용하면 Movie가 구체적인 클래스를 알지 못한 채 오직 역할에 대해서만 결합되도록 의존성을 제한할 수 있다.

![5-6](https://github.com/effectiveJava-study/Object/assets/10612909/aacc52c5-d15e-4f7c-a85a-a09d217ea76c)

역할을 사용하면 객체의 구체적인 타입을 추상화할 수 있다.

역할을 대체할 클래스들 사이에서 구현을 공유해야 할 필요가 있다면 추상 클래스를 사용하면 되고 구현을 공유할 필요 없이 역할을 대체하는 객체들의 책임만 정의하고 싶다면 인터페이스를 사용하면 된다.

![5-7](https://github.com/effectiveJava-study/Object/assets/10612909/7a61f63d-d5b5-4ad2-bddb-7ef96716a747)

객체의 암시적인 타입에 따라 행동을 분기해야 한다면 암시적인 타입을 명시적인 클래스로 정의하고 행동을 나눔으로써 응집도 문제를 해결할 수 있다. GRASP에서는 이를 **POLYMORPHISM(다형성)**  패턴이라 부른다

### 변경으로부터 보호하기

변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서는 **PROTECTED VARIATIONS(변경 보호)** 패턴이라고 부른다.

클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화하는 것은 설계의 결합도와 응집도를 향상시키는 매우 강력한 방법이다.

하나의 클래스가 여러 타입의 행동을 구현하고 있는것처럼 보인다면 클래스를 분해하고 **POLYMORPHISM** 패턴에 따라 책임을 분산시켜라. 예측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면 **PROTECTED VARIATIONS** 패턴에 따라 안정적인 인터페이스 뒤로 변경을 캡슐화하라.

### 변경과 유연성

설계를 주도하는 것은 변경이다. 개발자로서 변경에 대비할 수 있는 두 가지 방법이 있다.

- 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이다.
- 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것이다.

현재 설계에서는 할인 정책을 구현하기 위해 **상속**을 이용하고 있기 때문에 실행 중에 영화의 할인 정책을 변경하기 위해서는 새로운 인스턴스를 생선한 후 필요한 정보를 복사해야한다.

새로운 할인 정책이 추가될 때 마다 인스턴스를 생성하고, 상태를 복사하고, 식별자를 관리하는 코드를 추가하는 일은 번거로울뿐만 아니라 오류가 발생하기도 쉽다.

해결 방법은 상속 대신 **합성**을 사용하는 것이다.

![5-8](https://github.com/effectiveJava-study/Object/assets/10612909/dec4ac4a-ba9b-4be5-9b3c-c8c075bf3e51)

Movie의 상속 계층 안에 구현된 할인 정책을 독립적인 DiscountPolicy로 분리한 후 Movie에 합성시키면 유연한 설계가 완성된다.

## 04. 책임 주도 설계의 대한

코드를 수정한 후에 겉으로 드러나는 동작이 바뀌어서는 안된다. 캡슐화를 향상 시키고, 응집도를 높이고, 결합도를 낮춰야 하지만 동작은 그대로 유지해야 한다. 이처럼 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것을 **리팩터링(Refactoring)** 이라고 부른다.

### 메서드 응집도

긴 메서드가 코드 유지 보수의 부정적인 영향을 미치는 이유

- 어떤 일을 수행하는지 한눈에 파악하기 어렵기 때문에 코드를 전체적으로 이해하는 데 너무 많은 시간이 걸린다.
- 하나의 메서드 안에 너무 많은 작업을 처리하기 때문에 변경이 필요할 때 수정해야 할 부분을 찾기 어렵다.
- 메서드 내부의 일부 로직만 수정하더라도 메서드의 나머지 부분에서 버그가 발생할 확률이 높다.
- 로직의 일부만 재사용하는 것이 불가능하다.
- 코드를 재사용하는 유일한 방법은 원하는 코드를 복사해서 붙여넣는 것뿐이므로 코드 중복을 초래하기 쉽다.

긴 메서드는 응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어렵다. 마이클 페더스(Michael Feathers)는 이런 메서드를 **몬스터 메서드 (Monster Method)** 라고 부른다.

### 객체를 자율적으로 만들자

자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체를 만드는 지름길이다.

책임 주도 설계 방법에 익숙하지 않다면 일단 데이터 중심으로 구현한 후 이를 리팩터링하더라도 유사한 결과를 얻을 수 있다는 것이다. 처음부터 책임 주도 설계 방법을 따르는 것보다 동작하는 코드를 작성한 후에 리팩터링하는 것이 더 훌륭한 결과물을 낳을 수도 있다.
