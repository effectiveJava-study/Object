# Chapter07. 객체 분해

- 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업을 **추상화**
- 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 **분해**

---

## 01 프로시저 추상화와 데이터 추상화

### 두 가지 추상화 메커니즘

- **프로시저 추상화**
    - 프로시저 추상화를 중심으로 시스템을 분해하기 결정했다면 기능 분해의 길로 들어서는 것
    - 알고리즘 분해라고 부르기도 함.
- **데이터 추상화**
    - 타입을 추상화 = 추상데이터 타입
    - 프로시저를 추상화 = 객체 지향

---

## 02 프로시저 추상화와 기능 분해

### 메인 함수로서의 시스템

- 기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용 됐으며, 이것을 **알고리즘 분해** 또는 **기능 분해** 라고 함.
- 기능 분해의 관점에서 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해
- 기능 분해 방법은 하향식 접근법을 따름
    - 시스템을 구성하는 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말함
- 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해

### 급여관리 시스템

```java
직원의 급여를 계산한다
  사용자로부터 소득세율을 입력받는다.
    "세율을 입력하세요: "라는 문장을 화면에 출력한다.
    키보드를 통해 세율을 입력받는다.
  직원의 급여를 계산한다.
    전역 변수에 저장된 직원의 기본급 정보를 얻는다.
    급여를 계산한다.
  양식에 맞게 결과를 출력한다.
    "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.
```

```ruby
$employees = ["직원A", "직원B", "직원C"] # 직원 리스트
$basePays = [400, 300, 250] # 급여 리스트
 
def main(name)
  # 사용자로부터 소득세율을 입력받는다.
  taxRate = getTaxRate()
  # 직원의 급여를 계산한다.
  pay = calculatePayFor(name, tasRate)
  # 양식에 맞게 결과를 출력한다.
  puts(describeResult(name, pay))
end
 
def getTaxRate()
  print("세율을 입력하세요")
  return gets().comp().to_f()
end
 
def calculatePayFor(name, texRate)
  index = $employees.index(name)
  basePay = $basePays[index]
  return basePay - (basePay * taxRate)
end
 
def describeResult(name, pay)
  return "이름 #{name}, 급여: #{pay}"
end
 
# 이름이 직원C인 직원의 급여 계산.
main("직원C")
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd03780e-7d2f-4267-ba50-1ef59180f3c8/6cf878a8-9d4d-4c14-8b39-f9b8b2c06ee0/Untitled.png)

- 커다란 기능을 좀 더 작은 기능으로 단계적으로 정제해 가는 과정은 구조적이며 체계적인 동시에 이상적인 방법으로까지 보임
    - 우리가 사는 세계는 그렇지 않음

### 하향식 기능 분해의 문제점

- 시스템은 하나의 메인 함수로 구성돼 있지 않다.
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
- 비즈니스 로직이 사용자 인터페이스와 가앟게 결합된다.
- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.

하향식 접근법과 기능 분해가 가지는 근본적인 문제점은 변경에 취약한 설계를 낳는 것

- **하나의 메인 함수라는 비현실적인 아이디어**
    - 어떤 시스템도 최초에 릴리스됐던 당시의 모습을 그대로 유지하지 않음
    - 지속적으로 새로운 기능이 추가
- **메인 함수의 빈번한 재설계**
    - 하나의 메인 함수를 유일한 정상으로 간주하는 하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 함
    - 빈번한 수정으로 인한 버그 발생 확률이 높아지기 때문에 시스템은 변경에 취약해질 수 밖에 없음
- **비즈니스 로직과 사용자 인터페이스의 결합**
    - 하향식 접근법은 사용자 인터페이스 로직과 비즈니스 로직을 한데 섞기 때문에 사용자 인터페이스를 변경하는 경우 비즈니스 로직까지 변경에 영향을 받게 됨
- **성급하게 결정된 실행 순서**
    - 하향식으로 기능을 분해하는 과정은 하나의 함수를 더 작은 함수로 분해하고, 분해된 함수들의 실행순서를 결정하는 작업으로 요약 가능
    - 설계를 시작하는 시점부터 시스템이 무엇(what)을 해야 하는지가 아니라 어떻게(how) 동작해야 하는지에 집중하도록 함
    - 처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 실행 순서를 정의 하는 시간제약을 강조
    - 하향식 접근법을 통해 분해한 함수들은 재사용하기도 어렵
    - 하향식 설계와 관련된 모든 문제의 원인은 **결합도**
    - 전체 시스템의 핵심적인 구조를 결정하는 함수들이 데이터와 강하게 결합된다는 것
- **데이터 변경으로 인한 파급효과**
    - 하향식 기능 분해의 가장 큰 문제는 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다는 것
    - 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어려움

### 언제 하향식 분해가 유용한가?

- 설계가 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하기 때문

**하향식 설계의 문제점**

- 하나의 함수에 제어가 집중되기 때문에 확장이 어려움
- 사용자 인터페이스 같은 비본질적인 측면에 집중하게 함
- 데이터에 대한 영향도를 파악하기 어려움
- 재사용이 어려움

---

## 03 모듈

### 정보 은닉과 모듈

- 시스템의 변경을 관리하는 기본적인 전략은 함께 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 하는 것
- 기능을 기반으로 시스템을 분해하는 것이 아니라 변경의 방향에 맞춰 시스템을 분해하는 것
- **정보 은닉**은 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 던 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심
- **기능 분해**가 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정이라면 **모듈 분해**는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정

**모듈이 감춰야 하는 비밀**

- 복잡성 : 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다. 외부에 모듈을 추상화 할 수 있는 인터페이스를 추가하여 낮춤
- 변경 가능성 : 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정은 내부로, 쉽게 변경되지 않을 인터페이스는 외부로 제공

### 모듈의 장점과 한계

- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다
- 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
- 전역 변수와 전역함수를 제거함으로써 네임스페이스 오렴을 방지한다.

- 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 부해하게 함
    - 모듈 내부는 높은 응집도를 유지
    - 모듈과 모듈사이에서는 퍼블릭 인터페이스를 통해서만 통신
        - 낮은 결합도 유지
- 기능이 아니라 데이터 중심으로 시스템을 분해하는 것
- 프로시저 추상화보다는 높은 추상화 개념을 제공하지만 태생적으로 변경을 관리하기 위한 구현 기법이기 때문에 추상화 관점에서의 한계점이 명확

---

## 04 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

- 리스코프는 프로시저 추상화를 보완하기 위해 데이터 추상화 개념을 제안함
- 추상 데이터 타입은 말 그대로 시스템의 상태를 저장할 데이터를 표현
- 추상 데이터 타입의 기본 의도는 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게 하는것
    - 프로그래밍 언어의 내장 타입과 동일하지만 개발자가 정의할 수 있다는 점이 다름

---

## 05 클래스

### 클래스는 추상 데이터 타입인가?

- 두 메커니즘 모두 외부에서는 객체의 내부 속성에 접근할 수 없고, 오직 퍼블릭 인터페이스를 통해서만 외부와 의사소통할 수 있음
- 클래스는 상속과 다형성을 지원 / 추상 데이터타입은 지원X
- 상속과 다형성을 지원하는 **객체지향 프로그래밍**과 구분하기 위해 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 패러다임을 **객체기반 프로그래밍**이라 함.
- 추상 데이터 타입은 **타입**을 추상화한 것 / 클래스는 **절차**를 추상화 한것

- Employee 내부에는 정규 직원과 아르바이트 직원이라는 두 개의 타입이 공존
    - 직원 타입을 외부에 캡슐화 하고 있는 것 = 타입 추상화
- 부모클래스의 참조자에 대해 메시지를 전송하면 실제 클래스가 무엇인가에 따라 적절한 절차가 실행
    - 동일한 메시지에 대해 서로 다르게 반응 = 다형성
    - 객체 지향은 절차 추상화
- 추상 데이터 타입은 오퍼레이션을 기준으로 타입들을 추상화
클래스는 타입을 기준으로 절차들을 추상화

### 변경의 기준을 선택하라

- 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 **개방-폐쇄 원칙(OCP)** 이라함
