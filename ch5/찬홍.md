# Chapter05. 책임 할당하기

- 데이터 중심 설계는 행동보다 데이터를 먼저 결정
    - 캡슐화를 위반하기 쉬움
    - 요소들 사이의 결합도가 높아짐
    - 코드 변경이 어려움
- 데이터가 아닌 책임에 초점을 맞추는 것이 해결 방법
    - 어떤 객체에게 어떤 책임을 할당할지를 결정하기 쉽지 않음
    - **GRASP 패턴**
    

---

## 01 책임 주도 설계를 향해

데이터 중심 설계 → 책임 중심 설계 원칙

1. **데이터보다 행동을 먼저 결정하라**
    - 객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 행동
    - 데이터는 객체가 책임을 수행하는 데 필요한 재료를 제공
    - 객체지향 설계에서 가장 중요한 것은 적절한 객체에게 적절한 책임을 할당하는 능력
2. **협력이라는 문맥 안에서 책임을 결정하라**
    - 협력을 시작하는 주체는 메시지 전송자
        
        → 협력에 적합한 책임이란 **메시지 전송자**에게 적합한 책임을 의미
        
    - 메시지를 결정한 후에 객체를 선택해야 함
        - 메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것
    - 메시지가 클라이언트의 의도를 표현한다는 사실에 주목
    

> **객체에게 적절한 책임을 할당하기 위해서는 협력이라는 문맥을 고려해야 한다.**
> 

### 책임 주도 설계

**흐름**

1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
2. 시스템 책임을 더 작은 책임으로 분할한다.
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. 
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 

**핵심** : 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것

---

## 02 책임 할당을 위한 GRASP 패턴

### GRASP (”General Responsibility Assignment Software Patteren”)

일반적인 책임 할당ㅇ을 위한 소프트웨어 패턴
객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙의 집합을 패턴 형식으로 정리한 것

### 정보 전문가에게 책임을 할당하라

- 메시지는 메시지를 수신할 객체가 아니라 메시지를 전송할 객체의 의도를 반영해서 결정해야 함
1. 메시지를 전송할 객체는 무엇을 원하는가?
2. 메시지를 수신할 적합한 객체는 누구인가?
- 객체의 책임과 책임을 수행하는 데 필요한 상태는 동일한 객체안에 존재 해야함
    - 객체는 자신의 상태를 스스로 처리하는 자율적인 존재여야 함

**INFORMATION EXPERT(정보 전문가) 패턴** : 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것

- 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화를 유지할 수 있음
- 자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아짐

## 높은 응집도와 낮은 결합도

- 높은 응집도와 낮은 결합도는 객체에 책임을 할당할 때 항상 고려해야하는 기본원리
- 책임과 협력의 품질을 검토하는 데 사용할 수 있는 중요한 평가 기준

### LOW COUPLING(낮은 결합도)

- 변화의 영향을 줄이며 재사용성을 증가

### HIGH COHESION(높은 응집도)

- 복잡성을 관리할 수 있는 수준으로 유지

## 창조자에게 객체 생성 책임을 할당하라

### CREATOR(창조자) 패턴

- 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것
- 생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것
    - 즉, 두 객체는 서로 결합
- 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 **낮은 결합도를 유지**할 수 있게 함

### DiscountCondition 개선하기

- 변경에 취약한 클래스를 포함하고 있다는 것
    - 새로운 할인 조건 추가
    - 순번 조건을 판단하는 로직 변경
    - 기간 조건을 판단하는 로직이 변경되는 경우
- 변경의 이유에 따라 클래스를 분리해야 함

**코드를 통해 변경의 이유를 파악할 수 있는 방법**

1. 인스턴스 변수가 초기화 되는 시점을 살펴보는 것
    - 클래스의 속성이 서로 다른 시점에 초기화되거나 일부만 초기화된다는 것은 응집도가 낮다는 증거
    - 함께 초기화 되는 속성을 기준으로 코드를 분리해야 함
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴 보는 것
    - 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있음
    - 응집도를 높이기 위해서는 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 함

### 타입 분리하기

- DiscountCondition의 가장 큰 문제는 순번조건과 기간 조건이라는 두 개의 독립적인 타입이 하나의 클래스 안에 공존 한다는 것
    - 클래스 분리
- 클래스들의 응집도 향상
- 두 개의 서로 다른 클래스의 인스턴스 모두와 협력할 수 있어야 함

![image](https://github.com/effectiveJava-study/Object/assets/90807343/0b92b9de-c1e5-4c42-aad9-be7790d8805d)


**문제점**

- 클래스 양쪽에 결합 - 캡슐화
- 새로운 할인조건 추가의 어려움 - 변경

### 다형성을 통해 분리하기

- **역할**의 개념을 적용하면 구체적인 클래스는 알지 못한 채 오직 열할에 대해서만 결합되도록 의존성을 제한할 수 있음
- 구현을 공유 해야함 - 추상클래스
- 구현을 공유할 필요 없음 - 인터페이스

```java
public interface DiscountCondition {
    public boolean isSatisfiedBy(Screening screening);
}
```

**POLYMORPHISM(다형성) 패턴** : 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당 하는 것 

![image](https://github.com/effectiveJava-study/Object/assets/90807343/0e9c7c18-0a1a-40c0-9ed4-04ba39fecd32)


### 변경으로부터 보호하기

- 오직 DiscountCondition 인터페이스를 실체화하는 클래스를 추가하는 것으로 할인 조건의 종류를 확장할 수 있음
    - **PROTECTED VARIATIONS(변경 보호) 패턴** : 변경을 캡슐화하도록 책임을 할당하는 것

### 변경과 유연성

개발자로서 변경에 대비할 수 있는 방법

1. 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것
2. 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 유연하게 만드는 것

새로운 할인 정책 추가

→ 인스턴스 생성 → 상태 복사 → 식별자 관리 코드 추가

- 상속 대신 합성 사용

![image](https://github.com/effectiveJava-study/Object/assets/90807343/d143c033-a8a4-45f1-9df0-9392e9c67f72)


---

## 04 책임 주도 설계의 대안

**리팩터링** : 동작은 바꾸지 않은 채 내부 구조를 변경하는 것 

### 메서드 응집도

**몬스터 메서드** : 긴 메서드, 응지볻가 낮고, 이해하기 어렵고, 재사용하기도 어렵고, 변경이 어려운 메서드

```java
public Reservation reserve(Screening screening, Customer customer, int audienceCount){
    boolean discountable = checkDiscountable(screening);
    Money fee = calculateFee(screening, discountable, audienceCount);
    return createReservation(screening, customer, audienceCount, fee);
}
```

- 각 메서드는 단 하나의 이유에 의해서만 변경 됨
    - 응집도 높은 클래스

### 객체를 자율적으로 만들자

- 자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체를 만드는 지름길

> **처음부터 책임 주도 설계 방법을 따르는 것 보다 동작하는 코드를 작성한 후에 리팩터링 하는것이 더 훌룡한 결과물을 낳을 수 있다.**
>
